# Phase 1.5 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Refactor HoloMUSH into a two-process architecture (Gateway + Core) with proper CLI, structured logging, and observability.

**Architecture:** Single binary with subcommands. Core process wraps engine with gRPC server. Gateway process runs telnet server and forwards commands to Core via gRPC. mTLS authentication with auto-generated certificates. Control sockets for lifecycle management.

**Tech Stack:** Go 1.24, Cobra CLI, gRPC with protobuf, OpenTelemetry tracing, standard library crypto/tls

---

## Critical Cross-Dependencies

```text
                    ┌─────────────────────────────────────────┐
                    │           PHASE A (Parallel)            │
                    │  ┌─────┐  ┌─────────┐  ┌───────────┐   │
                    │  │ XDG │  │ Logging │  │ gRPC Proto│   │
                    │  └──┬──┘  └────┬────┘  └─────┬─────┘   │
                    └─────┼──────────┼─────────────┼─────────┘
                          │          │             │
                    ┌─────▼──────────┼─────────────┼─────────┐
                    │           PHASE B                       │
                    │    ┌──────────────────┐                 │
                    │    │ TLS Cert Gen     │←────────────────┤
                    │    │ (needs XDG)      │                 │
                    │    └────────┬─────────┘                 │
                    └─────────────┼───────────────────────────┘
                                  │
┌─────────────────────────────────┼───────────────────────────┐
│                           PHASE C                           │
│    ┌──────────────────┐         │                           │
│    │ DB Migration     │         │                           │
│    │ (game_id table)  │         │                           │
│    └────────┬─────────┘         │                           │
└─────────────┼───────────────────┼───────────────────────────┘
              │                   │
┌─────────────┼───────────────────┼───────────────────────────┐
│             │             PHASE D                           │
│             │    ┌──────────────────┐                       │
│             │    │ Cobra CLI        │←──(needs XDG, Logging)│
│             │    │ (skeleton)       │                       │
│             │    └────────┬─────────┘                       │
└─────────────┼─────────────┼─────────────────────────────────┘
              │             │
┌─────────────▼─────────────▼─────────────────────────────────┐
│                       PHASE E                               │
│    ┌────────────────────────────────────────────────────┐   │
│    │ Core Process                                       │   │
│    │ - gRPC server with TLS                             │   │
│    │ - Implements Core service (wraps Engine)           │   │
│    │ - Writes game_id to config file                    │   │
│    │ - Needs: XDG, Logging, TLS, CLI, Proto, DB         │   │
│    └────────────────────────┬───────────────────────────┘   │
└─────────────────────────────┼───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                       PHASE F                               │
│    ┌────────────────────────────────────────────────────┐   │
│    │ Gateway Process                                    │   │
│    │ - gRPC client with TLS                             │   │
│    │ - Reads game_id from config file                   │   │
│    │ - Telnet server forwards to Core                   │   │
│    │ - Auto-reconnect on Core restart                   │   │
│    │ - Needs: Core running for integration tests        │   │
│    └────────────────────────┬───────────────────────────┘   │
└─────────────────────────────┼───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                       PHASE G                               │
│    ┌────────────────────────────────────────────────────┐   │
│    │ Control Sockets                                    │   │
│    │ - HTTP server on Unix socket                       │   │
│    │ - /health, /ready, /shutdown endpoints             │   │
│    │ - CLI stop/status commands connect to socket       │   │
│    └────────────────────────┬───────────────────────────┘   │
└─────────────────────────────┼───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                       PHASE H                               │
│    ┌───────────────┐    ┌───────────────────────────────┐   │
│    │ Integration   │    │ Documentation                 │   │
│    │ Tests         │    │ (README, CLI, deployment)     │   │
│    └───────────────┘    └───────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

**Key Insight - game_id Problem:**

- game_id lives in database (Core has access)
- Gateway needs game_id to validate Core's cert SAN
- Gateway has NO database access
- **Solution:** Core writes game_id to `$XDG_CONFIG_HOME/holomush/gateway.yaml` on startup

---

## Phase A: Foundation (Parallel)

These three tasks have NO dependencies and can be implemented in parallel.

---

### Task A1: XDG Path Utilities

**Files:**

- Create: `internal/xdg/xdg.go`
- Create: `internal/xdg/xdg_test.go`

**Step 1: Write the failing tests**

```go
// internal/xdg/xdg_test.go
package xdg

import (
	"os"
	"path/filepath"
	"testing"
)

func TestConfigDir_EnvVar(t *testing.T) {
	t.Setenv("XDG_CONFIG_HOME", "/custom/config")
	got := ConfigDir()
	want := "/custom/config/holomush"
	if got != want {
		t.Errorf("ConfigDir() = %q, want %q", got, want)
	}
}

func TestConfigDir_Default(t *testing.T) {
	t.Setenv("XDG_CONFIG_HOME", "")
	t.Setenv("HOME", "/home/testuser")
	got := ConfigDir()
	want := "/home/testuser/.config/holomush"
	if got != want {
		t.Errorf("ConfigDir() = %q, want %q", got, want)
	}
}

func TestDataDir_EnvVar(t *testing.T) {
	t.Setenv("XDG_DATA_HOME", "/custom/data")
	got := DataDir()
	want := "/custom/data/holomush"
	if got != want {
		t.Errorf("DataDir() = %q, want %q", got, want)
	}
}

func TestDataDir_Default(t *testing.T) {
	t.Setenv("XDG_DATA_HOME", "")
	t.Setenv("HOME", "/home/testuser")
	got := DataDir()
	want := "/home/testuser/.local/share/holomush"
	if got != want {
		t.Errorf("DataDir() = %q, want %q", got, want)
	}
}

func TestStateDir_EnvVar(t *testing.T) {
	t.Setenv("XDG_STATE_HOME", "/custom/state")
	got := StateDir()
	want := "/custom/state/holomush"
	if got != want {
		t.Errorf("StateDir() = %q, want %q", got, want)
	}
}

func TestStateDir_Default(t *testing.T) {
	t.Setenv("XDG_STATE_HOME", "")
	t.Setenv("HOME", "/home/testuser")
	got := StateDir()
	want := "/home/testuser/.local/state/holomush"
	if got != want {
		t.Errorf("StateDir() = %q, want %q", got, want)
	}
}

func TestRuntimeDir_EnvVar(t *testing.T) {
	t.Setenv("XDG_RUNTIME_DIR", "/run/user/1000")
	got := RuntimeDir()
	want := "/run/user/1000/holomush"
	if got != want {
		t.Errorf("RuntimeDir() = %q, want %q", got, want)
	}
}

func TestRuntimeDir_Fallback(t *testing.T) {
	t.Setenv("XDG_RUNTIME_DIR", "")
	t.Setenv("XDG_STATE_HOME", "/custom/state")
	got := RuntimeDir()
	want := "/custom/state/holomush/run"
	if got != want {
		t.Errorf("RuntimeDir() = %q, want %q", got, want)
	}
}

func TestCertsDir(t *testing.T) {
	t.Setenv("XDG_CONFIG_HOME", "/custom/config")
	got := CertsDir()
	want := "/custom/config/holomush/certs"
	if got != want {
		t.Errorf("CertsDir() = %q, want %q", got, want)
	}
}

func TestEnsureDir(t *testing.T) {
	tmpDir := t.TempDir()
	testPath := filepath.Join(tmpDir, "nested", "dir")

	err := EnsureDir(testPath)
	if err != nil {
		t.Fatalf("EnsureDir() error = %v", err)
	}

	info, err := os.Stat(testPath)
	if err != nil {
		t.Fatalf("Stat() error = %v", err)
	}
	if !info.IsDir() {
		t.Error("Expected directory, got file")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `task test -- -run TestConfigDir -v ./internal/xdg/...`
Expected: FAIL with "no Go files in"

**Step 3: Write minimal implementation**

```go
// internal/xdg/xdg.go
package xdg

import (
	"os"
	"path/filepath"
)

const appName = "holomush"

// ConfigDir returns the XDG config directory for holomush.
// Checks XDG_CONFIG_HOME first, falls back to ~/.config.
func ConfigDir() string {
	base := os.Getenv("XDG_CONFIG_HOME")
	if base == "" {
		base = filepath.Join(os.Getenv("HOME"), ".config")
	}
	return filepath.Join(base, appName)
}

// DataDir returns the XDG data directory for holomush.
// Checks XDG_DATA_HOME first, falls back to ~/.local/share.
func DataDir() string {
	base := os.Getenv("XDG_DATA_HOME")
	if base == "" {
		base = filepath.Join(os.Getenv("HOME"), ".local", "share")
	}
	return filepath.Join(base, appName)
}

// StateDir returns the XDG state directory for holomush.
// Checks XDG_STATE_HOME first, falls back to ~/.local/state.
func StateDir() string {
	base := os.Getenv("XDG_STATE_HOME")
	if base == "" {
		base = filepath.Join(os.Getenv("HOME"), ".local", "state")
	}
	return filepath.Join(base, appName)
}

// RuntimeDir returns the XDG runtime directory for holomush.
// Checks XDG_RUNTIME_DIR first, falls back to StateDir()/run.
func RuntimeDir() string {
	base := os.Getenv("XDG_RUNTIME_DIR")
	if base == "" {
		return filepath.Join(StateDir(), "run")
	}
	return filepath.Join(base, appName)
}

// CertsDir returns the TLS certificates directory.
func CertsDir() string {
	return filepath.Join(ConfigDir(), "certs")
}

// EnsureDir creates a directory and all parent directories if they don't exist.
func EnsureDir(path string) error {
	return os.MkdirAll(path, 0o700)
}
```

**Step 4: Run test to verify it passes**

Run: `task test -- -run Test -v ./internal/xdg/...`
Expected: PASS

**Step 5: Lint and commit**

```bash
task lint
git add internal/xdg/
git commit -m "feat(xdg): add XDG Base Directory utilities"
```

---

### Task A2: Structured Logging with OTEL Trace Context

**Files:**

- Create: `internal/logging/handler.go`
- Create: `internal/logging/handler_test.go`

**Step 1: Write the failing tests**

```go
// internal/logging/handler_test.go
package logging

import (
	"bytes"
	"context"
	"encoding/json"
	"log/slog"
	"strings"
	"testing"

	"go.opentelemetry.io/otel/trace"
)

func TestSetup_JSONFormat(t *testing.T) {
	var buf bytes.Buffer
	logger := Setup("core", "1.0.0", "json", &buf)

	logger.Info("test message")

	var entry map[string]any
	if err := json.Unmarshal(buf.Bytes(), &entry); err != nil {
		t.Fatalf("Failed to parse JSON: %v\nOutput: %s", err, buf.String())
	}

	if entry["msg"] != "test message" {
		t.Errorf("msg = %v, want 'test message'", entry["msg"])
	}
	if entry["service"] != "core" {
		t.Errorf("service = %v, want 'core'", entry["service"])
	}
	if entry["version"] != "1.0.0" {
		t.Errorf("version = %v, want '1.0.0'", entry["version"])
	}
	if _, ok := entry["time"]; !ok {
		t.Error("time field missing")
	}
	if _, ok := entry["level"]; !ok {
		t.Error("level field missing")
	}
}

func TestSetup_TextFormat(t *testing.T) {
	var buf bytes.Buffer
	logger := Setup("gateway", "1.0.0", "text", &buf)

	logger.Info("test message")

	output := buf.String()
	if !strings.Contains(output, "test message") {
		t.Errorf("Output missing message: %s", output)
	}
	if !strings.Contains(output, "gateway") {
		t.Errorf("Output missing service: %s", output)
	}
}

func TestHandler_TraceContext(t *testing.T) {
	var buf bytes.Buffer
	logger := Setup("core", "1.0.0", "json", &buf)

	// Create a mock span context
	traceID, _ := trace.TraceIDFromHex("4bf92f3577b34da6a3ce929d0e0e4736")
	spanID, _ := trace.SpanIDFromHex("00f067aa0ba902b7")
	spanCtx := trace.NewSpanContext(trace.SpanContextConfig{
		TraceID: traceID,
		SpanID:  spanID,
	})
	ctx := trace.ContextWithSpanContext(context.Background(), spanCtx)

	logger.InfoContext(ctx, "traced message")

	var entry map[string]any
	if err := json.Unmarshal(buf.Bytes(), &entry); err != nil {
		t.Fatalf("Failed to parse JSON: %v", err)
	}

	if entry["trace_id"] != "4bf92f3577b34da6a3ce929d0e0e4736" {
		t.Errorf("trace_id = %v, want '4bf92f3577b34da6a3ce929d0e0e4736'", entry["trace_id"])
	}
	if entry["span_id"] != "00f067aa0ba902b7" {
		t.Errorf("span_id = %v, want '00f067aa0ba902b7'", entry["span_id"])
	}
}

func TestHandler_NoTraceContext(t *testing.T) {
	var buf bytes.Buffer
	logger := Setup("core", "1.0.0", "json", &buf)

	logger.Info("no trace message")

	var entry map[string]any
	if err := json.Unmarshal(buf.Bytes(), &entry); err != nil {
		t.Fatalf("Failed to parse JSON: %v", err)
	}

	// trace_id and span_id should be empty strings or missing
	if tid, ok := entry["trace_id"]; ok && tid != "" {
		t.Errorf("trace_id should be empty, got %v", tid)
	}
	if sid, ok := entry["span_id"]; ok && sid != "" {
		t.Errorf("span_id should be empty, got %v", sid)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `task test -- -run TestSetup -v ./internal/logging/...`
Expected: FAIL with "no Go files in" or undefined Setup

**Step 3: Write minimal implementation**

```go
// internal/logging/handler.go
package logging

import (
	"context"
	"io"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel/trace"
)

// traceHandler wraps a slog.Handler to add trace context.
type traceHandler struct {
	handler slog.Handler
	service string
	version string
}

// Handle adds trace context to the log record.
func (h *traceHandler) Handle(ctx context.Context, r slog.Record) error {
	// Add service and version
	r.AddAttrs(
		slog.String("service", h.service),
		slog.String("version", h.version),
	)

	// Extract trace context if present
	spanCtx := trace.SpanContextFromContext(ctx)
	if spanCtx.HasTraceID() {
		r.AddAttrs(slog.String("trace_id", spanCtx.TraceID().String()))
	}
	if spanCtx.HasSpanID() {
		r.AddAttrs(slog.String("span_id", spanCtx.SpanID().String()))
	}

	return h.handler.Handle(ctx, r)
}

// Enabled returns true if the level is enabled.
func (h *traceHandler) Enabled(ctx context.Context, level slog.Level) bool {
	return h.handler.Enabled(ctx, level)
}

// WithAttrs returns a new handler with the given attributes.
func (h *traceHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	return &traceHandler{
		handler: h.handler.WithAttrs(attrs),
		service: h.service,
		version: h.version,
	}
}

// WithGroup returns a new handler with the given group.
func (h *traceHandler) WithGroup(name string) slog.Handler {
	return &traceHandler{
		handler: h.handler.WithGroup(name),
		service: h.service,
		version: h.version,
	}
}

// Setup creates a configured slog.Logger.
// format: "json" or "text"
// If w is nil, writes to os.Stderr.
func Setup(service, version, format string, w io.Writer) *slog.Logger {
	if w == nil {
		w = os.Stderr
	}

	var baseHandler slog.Handler
	opts := &slog.HandlerOptions{
		Level: slog.LevelDebug,
	}

	if format == "text" {
		baseHandler = slog.NewTextHandler(w, opts)
	} else {
		baseHandler = slog.NewJSONHandler(w, opts)
	}

	handler := &traceHandler{
		handler: baseHandler,
		service: service,
		version: version,
	}

	return slog.New(handler)
}

// SetDefault sets up and configures the default logger.
func SetDefault(service, version, format string) {
	logger := Setup(service, version, format, nil)
	slog.SetDefault(logger)
}
```

**Step 4: Run test to verify it passes**

Run: `task test -- -run Test -v ./internal/logging/...`
Expected: PASS

**Step 5: Lint and commit**

```bash
task lint
git add internal/logging/
git commit -m "feat(logging): add structured logging with OTEL trace context"
```

---

### Task A3: gRPC Proto Definitions and Codegen

**Files:**

- Create: `api/proto/holomush/core/v1/core.proto`
- Create: `buf.yaml`
- Create: `buf.gen.yaml`
- Modify: `Taskfile.yaml` (add proto task)
- Generated: `internal/proto/holomush/core/v1/*.go`

**Step 1: Create proto directory structure**

```bash
mkdir -p api/proto/holomush/core/v1
```

**Step 2: Write the proto file**

```protobuf
// api/proto/holomush/core/v1/core.proto
syntax = "proto3";

package holomush.core.v1;

option go_package = "github.com/holomush/holomush/internal/proto/holomush/core/v1;corev1";

import "google/protobuf/timestamp.proto";

// RequestMeta contains metadata for request correlation and debugging.
message RequestMeta {
  string request_id = 1;                    // ULID for log correlation
  google.protobuf.Timestamp timestamp = 2;
}

// ResponseMeta contains metadata echoed back from requests.
message ResponseMeta {
  string request_id = 1;                    // Echoed from request
  google.protobuf.Timestamp timestamp = 2;
}

// Core is the main game service.
service Core {
  // Authenticate validates credentials and creates a session.
  rpc Authenticate(AuthRequest) returns (AuthResponse);

  // HandleCommand processes a game command.
  rpc HandleCommand(CommandRequest) returns (CommandResponse);

  // Subscribe opens a stream of events for the session.
  rpc Subscribe(SubscribeRequest) returns (stream Event);

  // Disconnect ends a session.
  rpc Disconnect(DisconnectRequest) returns (DisconnectResponse);
}

message AuthRequest {
  RequestMeta meta = 1;
  string username = 2;
  string password = 3;
}

message AuthResponse {
  ResponseMeta meta = 1;
  bool success = 2;
  string session_id = 3;
  string character_id = 4;
  string character_name = 5;
  string error = 6;
}

message CommandRequest {
  RequestMeta meta = 1;
  string session_id = 2;
  string command = 3;
}

message CommandResponse {
  ResponseMeta meta = 1;
  bool success = 2;
  string output = 3;
  string error = 4;
}

message SubscribeRequest {
  RequestMeta meta = 1;
  string session_id = 2;
  repeated string streams = 3;
}

message Event {
  string id = 1;
  string stream = 2;
  string type = 3;
  google.protobuf.Timestamp timestamp = 4;
  string actor_type = 5;
  string actor_id = 6;
  bytes payload = 7;
}

message DisconnectRequest {
  RequestMeta meta = 1;
  string session_id = 2;
}

message DisconnectResponse {
  ResponseMeta meta = 1;
  bool success = 2;
}
```

**Step 3: Create buf.yaml**

```yaml
# buf.yaml
version: v2
modules:
  - path: api/proto
deps:
  - buf.build/googleapis/googleapis
lint:
  use:
    - STANDARD
breaking:
  use:
    - FILE
```

**Step 4: Create buf.gen.yaml**

```yaml
# buf.gen.yaml
version: v2
managed:
  enabled: true
  override:
    - file_option: go_package_prefix
      value: github.com/holomush/holomush/internal/proto
plugins:
  - remote: buf.build/protocolbuffers/go
    out: internal/proto
    opt: paths=source_relative
  - remote: buf.build/grpc/go
    out: internal/proto
    opt: paths=source_relative
```

**Step 5: Add proto task to Taskfile.yaml**

Add after the `test` task:

```yaml
proto:
  desc: Generate Go code from protobuf definitions
  cmds:
    - buf generate
  sources:
    - api/proto/**/*.proto
    - buf.yaml
    - buf.gen.yaml
  generates:
    - internal/proto/**/*.go
```

**Step 6: Add gRPC dependencies**

```bash
go get google.golang.org/grpc
go get google.golang.org/protobuf
```

**Step 7: Install buf and generate**

```bash
# Install buf if not present
go install github.com/bufbuild/buf/cmd/buf@latest

# Generate
task proto
```

**Step 8: Verify generated code compiles**

```bash
go build ./...
```

**Step 9: Lint and commit**

```bash
task lint
git add api/proto/ buf.yaml buf.gen.yaml internal/proto/ Taskfile.yaml go.mod go.sum
git commit -m "feat(proto): add gRPC Core service definitions"
```

---

## Phase B: Crypto (Depends on A1)

---

### Task B1: TLS Certificate Generation

**Files:**

- Create: `internal/tls/certs.go`
- Create: `internal/tls/certs_test.go`

**Dependencies:** Task A1 (XDG paths for cert storage)

**Step 1: Write the failing tests**

```go
// internal/tls/certs_test.go
package tls

import (
	"crypto/tls"
	"crypto/x509"
	"path/filepath"
	"testing"
)

func TestGenerateCA(t *testing.T) {
	tmpDir := t.TempDir()

	ca, err := GenerateCA(tmpDir)
	if err != nil {
		t.Fatalf("GenerateCA() error = %v", err)
	}

	// Verify CA cert exists
	certPath := filepath.Join(tmpDir, "root-ca.crt")
	keyPath := filepath.Join(tmpDir, "root-ca.key")

	cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		t.Fatalf("Failed to load CA: %v", err)
	}

	x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
	if err != nil {
		t.Fatalf("Failed to parse cert: %v", err)
	}

	if !x509Cert.IsCA {
		t.Error("Certificate is not a CA")
	}

	if ca.Certificate == nil {
		t.Error("CA certificate is nil")
	}
}

func TestGenerateServerCert(t *testing.T) {
	tmpDir := t.TempDir()

	ca, err := GenerateCA(tmpDir)
	if err != nil {
		t.Fatalf("GenerateCA() error = %v", err)
	}

	gameID := "01ABC123"
	err = GenerateServerCert(tmpDir, ca, gameID)
	if err != nil {
		t.Fatalf("GenerateServerCert() error = %v", err)
	}

	// Verify server cert exists and has correct SAN
	certPath := filepath.Join(tmpDir, "core.crt")
	keyPath := filepath.Join(tmpDir, "core.key")

	cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		t.Fatalf("Failed to load server cert: %v", err)
	}

	x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
	if err != nil {
		t.Fatalf("Failed to parse cert: %v", err)
	}

	// Check SAN includes game_id
	expectedSAN := "holomush-" + gameID
	found := false
	for _, name := range x509Cert.DNSNames {
		if name == expectedSAN {
			found = true
			break
		}
	}
	if !found {
		t.Errorf("SAN missing %q, got %v", expectedSAN, x509Cert.DNSNames)
	}
}

func TestGenerateClientCert(t *testing.T) {
	tmpDir := t.TempDir()

	ca, err := GenerateCA(tmpDir)
	if err != nil {
		t.Fatalf("GenerateCA() error = %v", err)
	}

	err = GenerateClientCert(tmpDir, ca)
	if err != nil {
		t.Fatalf("GenerateClientCert() error = %v", err)
	}

	// Verify client cert exists
	certPath := filepath.Join(tmpDir, "gateway.crt")
	keyPath := filepath.Join(tmpDir, "gateway.key")

	cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		t.Fatalf("Failed to load client cert: %v", err)
	}

	x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
	if err != nil {
		t.Fatalf("Failed to parse cert: %v", err)
	}

	if x509Cert.Subject.CommonName != "holomush-gateway" {
		t.Errorf("CN = %q, want 'holomush-gateway'", x509Cert.Subject.CommonName)
	}
}

func TestLoadServerTLS(t *testing.T) {
	tmpDir := t.TempDir()

	ca, err := GenerateCA(tmpDir)
	if err != nil {
		t.Fatalf("GenerateCA() error = %v", err)
	}

	err = GenerateServerCert(tmpDir, ca, "test123")
	if err != nil {
		t.Fatalf("GenerateServerCert() error = %v", err)
	}

	err = GenerateClientCert(tmpDir, ca)
	if err != nil {
		t.Fatalf("GenerateClientCert() error = %v", err)
	}

	config, err := LoadServerTLS(tmpDir)
	if err != nil {
		t.Fatalf("LoadServerTLS() error = %v", err)
	}

	if config.ClientAuth != tls.RequireAndVerifyClientCert {
		t.Error("Expected mTLS with client cert verification")
	}
}

func TestLoadClientTLS(t *testing.T) {
	tmpDir := t.TempDir()

	ca, err := GenerateCA(tmpDir)
	if err != nil {
		t.Fatalf("GenerateCA() error = %v", err)
	}

	err = GenerateServerCert(tmpDir, ca, "test123")
	if err != nil {
		t.Fatalf("GenerateServerCert() error = %v", err)
	}

	err = GenerateClientCert(tmpDir, ca)
	if err != nil {
		t.Fatalf("GenerateClientCert() error = %v", err)
	}

	config, err := LoadClientTLS(tmpDir, "test123")
	if err != nil {
		t.Fatalf("LoadClientTLS() error = %v", err)
	}

	if config.RootCAs == nil {
		t.Error("Expected root CA pool")
	}
	if len(config.Certificates) == 0 {
		t.Error("Expected client certificate")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `task test -- -run TestGenerate -v ./internal/tls/...`
Expected: FAIL

**Step 3: Write implementation**

```go
// internal/tls/certs.go
package tls

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"path/filepath"
	"time"
)

// CA holds a certificate authority.
type CA struct {
	Certificate *x509.Certificate
	PrivateKey  *ecdsa.PrivateKey
}

// GenerateCA creates a new root CA and saves it to the certs directory.
func GenerateCA(certsDir string) (*CA, error) {
	key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate CA key: %w", err)
	}

	serial, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return nil, fmt.Errorf("failed to generate serial: %w", err)
	}

	template := &x509.Certificate{
		SerialNumber: serial,
		Subject: pkix.Name{
			Organization: []string{"HoloMUSH"},
			CommonName:   "HoloMUSH Root CA",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(10, 0, 0), // 10 years
		IsCA:                  true,
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,
		BasicConstraintsValid: true,
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, template, template, &key.PublicKey, key)
	if err != nil {
		return nil, fmt.Errorf("failed to create CA certificate: %w", err)
	}

	cert, err := x509.ParseCertificate(certBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse CA certificate: %w", err)
	}

	// Save to files
	if err := os.MkdirAll(certsDir, 0o700); err != nil {
		return nil, fmt.Errorf("failed to create certs directory: %w", err)
	}

	if err := saveCert(filepath.Join(certsDir, "root-ca.crt"), certBytes); err != nil {
		return nil, err
	}
	if err := saveKey(filepath.Join(certsDir, "root-ca.key"), key); err != nil {
		return nil, err
	}

	return &CA{Certificate: cert, PrivateKey: key}, nil
}

// GenerateServerCert creates a server certificate for Core.
func GenerateServerCert(certsDir string, ca *CA, gameID string) error {
	key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return fmt.Errorf("failed to generate server key: %w", err)
	}

	serial, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return fmt.Errorf("failed to generate serial: %w", err)
	}

	template := &x509.Certificate{
		SerialNumber: serial,
		Subject: pkix.Name{
			Organization: []string{"HoloMUSH"},
			CommonName:   "holomush-core",
		},
		NotBefore:   time.Now(),
		NotAfter:    time.Now().AddDate(1, 0, 0), // 1 year
		KeyUsage:    x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		DNSNames:    []string{"localhost", "holomush-" + gameID},
		IPAddresses: []net.IP{net.ParseIP("127.0.0.1")},
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, template, ca.Certificate, &key.PublicKey, ca.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to create server certificate: %w", err)
	}

	if err := saveCert(filepath.Join(certsDir, "core.crt"), certBytes); err != nil {
		return err
	}
	if err := saveKey(filepath.Join(certsDir, "core.key"), key); err != nil {
		return err
	}

	return nil
}

// GenerateClientCert creates a client certificate for Gateway.
func GenerateClientCert(certsDir string, ca *CA) error {
	key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return fmt.Errorf("failed to generate client key: %w", err)
	}

	serial, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return fmt.Errorf("failed to generate serial: %w", err)
	}

	template := &x509.Certificate{
		SerialNumber: serial,
		Subject: pkix.Name{
			Organization: []string{"HoloMUSH"},
			CommonName:   "holomush-gateway",
		},
		NotBefore:   time.Now(),
		NotAfter:    time.Now().AddDate(1, 0, 0), // 1 year
		KeyUsage:    x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, template, ca.Certificate, &key.PublicKey, ca.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to create client certificate: %w", err)
	}

	if err := saveCert(filepath.Join(certsDir, "gateway.crt"), certBytes); err != nil {
		return err
	}
	if err := saveKey(filepath.Join(certsDir, "gateway.key"), key); err != nil {
		return err
	}

	return nil
}

// LoadServerTLS loads TLS config for the Core gRPC server.
func LoadServerTLS(certsDir string) (*tls.Config, error) {
	cert, err := tls.LoadX509KeyPair(
		filepath.Join(certsDir, "core.crt"),
		filepath.Join(certsDir, "core.key"),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to load server certificate: %w", err)
	}

	caCert, err := os.ReadFile(filepath.Join(certsDir, "root-ca.crt"))
	if err != nil {
		return nil, fmt.Errorf("failed to read CA certificate: %w", err)
	}

	caPool := x509.NewCertPool()
	if !caPool.AppendCertsFromPEM(caCert) {
		return nil, fmt.Errorf("failed to add CA certificate to pool")
	}

	return &tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientCAs:    caPool,
		ClientAuth:   tls.RequireAndVerifyClientCert,
		MinVersion:   tls.VersionTLS13,
	}, nil
}

// LoadClientTLS loads TLS config for the Gateway gRPC client.
func LoadClientTLS(certsDir string, expectedGameID string) (*tls.Config, error) {
	cert, err := tls.LoadX509KeyPair(
		filepath.Join(certsDir, "gateway.crt"),
		filepath.Join(certsDir, "gateway.key"),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to load client certificate: %w", err)
	}

	caCert, err := os.ReadFile(filepath.Join(certsDir, "root-ca.crt"))
	if err != nil {
		return nil, fmt.Errorf("failed to read CA certificate: %w", err)
	}

	caPool := x509.NewCertPool()
	if !caPool.AppendCertsFromPEM(caCert) {
		return nil, fmt.Errorf("failed to add CA certificate to pool")
	}

	return &tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      caPool,
		ServerName:   "holomush-" + expectedGameID,
		MinVersion:   tls.VersionTLS13,
	}, nil
}

// EnsureCerts generates certificates if they don't exist.
func EnsureCerts(certsDir string, gameID string) error {
	caPath := filepath.Join(certsDir, "root-ca.crt")
	if _, err := os.Stat(caPath); err == nil {
		return nil // Certs already exist
	}

	ca, err := GenerateCA(certsDir)
	if err != nil {
		return err
	}

	if err := GenerateServerCert(certsDir, ca, gameID); err != nil {
		return err
	}

	if err := GenerateClientCert(certsDir, ca); err != nil {
		return err
	}

	return nil
}

func saveCert(path string, certBytes []byte) error {
	f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o600)
	if err != nil {
		return fmt.Errorf("failed to create cert file: %w", err)
	}
	defer f.Close()

	return pem.Encode(f, &pem.Block{Type: "CERTIFICATE", Bytes: certBytes})
}

func saveKey(path string, key *ecdsa.PrivateKey) error {
	keyBytes, err := x509.MarshalECPrivateKey(key)
	if err != nil {
		return fmt.Errorf("failed to marshal key: %w", err)
	}

	f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o600)
	if err != nil {
		return fmt.Errorf("failed to create key file: %w", err)
	}
	defer f.Close()

	return pem.Encode(f, &pem.Block{Type: "EC PRIVATE KEY", Bytes: keyBytes})
}
```

**Step 4: Run tests**

Run: `task test -- -run Test -v ./internal/tls/...`
Expected: PASS

**Step 5: Lint and commit**

```bash
task lint
git add internal/tls/
git commit -m "feat(tls): add mTLS certificate generation and loading"
```

---

## Phase C: Database Migration

---

### Task C1: game_id Database Table

**Files:**

- Create: `internal/store/migrations/002_system_info.sql`
- Modify: `internal/store/postgres.go` (add GetSystemInfo, SetSystemInfo)
- Create: `internal/store/system_test.go`

**Step 1: Write the migration**

```sql
-- internal/store/migrations/002_system_info.sql
CREATE TABLE IF NOT EXISTS holomush_system_info (
    key         TEXT PRIMARY KEY,
    value       TEXT NOT NULL,
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    updated_at  TIMESTAMPTZ DEFAULT NOW()
);
```

**Step 2: Write the failing tests**

```go
// internal/store/system_test.go
package store

import (
	"context"
	"testing"
)

func TestPostgresEventStore_SystemInfo(t *testing.T) {
	// Skip if no test database
	if testing.Short() {
		t.Skip("Skipping integration test")
	}

	ctx := context.Background()
	store := setupTestStore(t) // Helper that creates test DB
	defer store.Close()

	// Test SetSystemInfo
	err := store.SetSystemInfo(ctx, "game_id", "01ABC123")
	if err != nil {
		t.Fatalf("SetSystemInfo() error = %v", err)
	}

	// Test GetSystemInfo
	value, err := store.GetSystemInfo(ctx, "game_id")
	if err != nil {
		t.Fatalf("GetSystemInfo() error = %v", err)
	}
	if value != "01ABC123" {
		t.Errorf("GetSystemInfo() = %q, want '01ABC123'", value)
	}

	// Test update
	err = store.SetSystemInfo(ctx, "game_id", "02DEF456")
	if err != nil {
		t.Fatalf("SetSystemInfo() update error = %v", err)
	}

	value, err = store.GetSystemInfo(ctx, "game_id")
	if err != nil {
		t.Fatalf("GetSystemInfo() error = %v", err)
	}
	if value != "02DEF456" {
		t.Errorf("GetSystemInfo() = %q, want '02DEF456'", value)
	}
}
```

**Step 3: Add methods to postgres.go**

```go
// Add to internal/store/postgres.go

// GetSystemInfo retrieves a system info value.
func (s *PostgresEventStore) GetSystemInfo(ctx context.Context, key string) (string, error) {
	var value string
	err := s.pool.QueryRow(ctx,
		`SELECT value FROM holomush_system_info WHERE key = $1`,
		key).Scan(&value)
	if err != nil {
		return "", fmt.Errorf("failed to get system info %q: %w", key, err)
	}
	return value, nil
}

// SetSystemInfo sets a system info value (upsert).
func (s *PostgresEventStore) SetSystemInfo(ctx context.Context, key, value string) error {
	_, err := s.pool.Exec(ctx,
		`INSERT INTO holomush_system_info (key, value) VALUES ($1, $2)
		 ON CONFLICT (key) DO UPDATE SET value = $2, updated_at = NOW()`,
		key, value)
	if err != nil {
		return fmt.Errorf("failed to set system info %q: %w", key, err)
	}
	return nil
}

// InitGameID ensures a game_id exists, generating one if needed.
func (s *PostgresEventStore) InitGameID(ctx context.Context) (string, error) {
	gameID, err := s.GetSystemInfo(ctx, "game_id")
	if err == nil {
		return gameID, nil
	}

	// Generate new game_id
	gameID = core.NewULID().String()
	if err := s.SetSystemInfo(ctx, "game_id", gameID); err != nil {
		return "", err
	}
	return gameID, nil
}
```

**Step 4: Update schema.sql embed to include migration**

Add to the schema embed or run migration separately.

**Step 5: Run tests and commit**

```bash
task test
task lint
git add internal/store/
git commit -m "feat(store): add system_info table for game_id storage"
```

---

## Phase D: CLI Structure

---

### Task D1: Cobra CLI Skeleton

**Files:**

- Modify: `cmd/holomush/main.go` (replace with Cobra root)
- Create: `cmd/holomush/root.go`
- Create: `cmd/holomush/gateway.go`
- Create: `cmd/holomush/core.go`
- Create: `cmd/holomush/cmd_test.go`

**Dependencies:** Tasks A1 (XDG), A2 (Logging)

**Step 1: Add Cobra dependency**

```bash
go get github.com/spf13/cobra
```

**Step 2: Write tests**

```go
// cmd/holomush/cmd_test.go
package main

import (
	"bytes"
	"testing"
)

func TestRootCommand_Help(t *testing.T) {
	cmd := NewRootCmd()
	buf := new(bytes.Buffer)
	cmd.SetOut(buf)
	cmd.SetArgs([]string{"--help"})

	if err := cmd.Execute(); err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	output := buf.String()
	if !bytes.Contains([]byte(output), []byte("gateway")) {
		t.Error("Help missing 'gateway' command")
	}
	if !bytes.Contains([]byte(output), []byte("core")) {
		t.Error("Help missing 'core' command")
	}
}

func TestGatewayCommand_Flags(t *testing.T) {
	cmd := NewRootCmd()
	cmd.SetArgs([]string{"gateway", "--help"})

	buf := new(bytes.Buffer)
	cmd.SetOut(buf)

	if err := cmd.Execute(); err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	output := buf.String()
	if !bytes.Contains([]byte(output), []byte("--telnet-addr")) {
		t.Error("Gateway missing --telnet-addr flag")
	}
	if !bytes.Contains([]byte(output), []byte("--core-addr")) {
		t.Error("Gateway missing --core-addr flag")
	}
}

func TestCoreCommand_Flags(t *testing.T) {
	cmd := NewRootCmd()
	cmd.SetArgs([]string{"core", "--help"})

	buf := new(bytes.Buffer)
	cmd.SetOut(buf)

	if err := cmd.Execute(); err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	output := buf.String()
	if !bytes.Contains([]byte(output), []byte("--grpc-addr")) {
		t.Error("Core missing --grpc-addr flag")
	}
	if !bytes.Contains([]byte(output), []byte("--database-url")) {
		t.Error("Core missing --database-url flag")
	}
}
```

**Step 3: Implement root.go**

```go
// cmd/holomush/root.go
package main

import (
	"github.com/spf13/cobra"
)

var (
	// Global flags
	logFormat    string
	otlpEndpoint string
	configDir    string
	dataDir      string
)

func NewRootCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "holomush",
		Short: "HoloMUSH - A modern MUSH platform",
		Long:  `HoloMUSH is a modern MUSH platform with event sourcing and plugin support.`,
	}

	// Global flags
	cmd.PersistentFlags().StringVar(&logFormat, "log-format", "json", "Log format: json or text")
	cmd.PersistentFlags().StringVar(&otlpEndpoint, "otlp-endpoint", "", "OTLP collector endpoint")
	cmd.PersistentFlags().StringVar(&configDir, "config-dir", "", "Override config directory")
	cmd.PersistentFlags().StringVar(&dataDir, "data-dir", "", "Override data directory")

	// Add subcommands
	cmd.AddCommand(NewGatewayCmd())
	cmd.AddCommand(NewCoreCmd())
	cmd.AddCommand(NewStatusCmd())

	return cmd
}

func NewStatusCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "status",
		Short: "Show health of all components",
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.Println("Checking status...")
			// TODO: Implement in Phase G
			return nil
		},
	}
}
```

**Step 4: Implement gateway.go**

```go
// cmd/holomush/gateway.go
package main

import (
	"github.com/spf13/cobra"
)

var (
	gatewayTelnetAddr string
	gatewayCoreAddr   string
	gatewayGameID     string
)

func NewGatewayCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "gateway",
		Short: "Start the gateway process (protocol servers)",
		RunE:  runGateway,
	}

	cmd.Flags().StringVar(&gatewayTelnetAddr, "telnet-addr", ":4201", "Telnet listen address")
	cmd.Flags().StringVar(&gatewayCoreAddr, "core-addr", "localhost:9000", "Core gRPC address")
	cmd.Flags().StringVar(&gatewayGameID, "game-id", "", "Expected game_id for cert validation")

	// Subcommands
	cmd.AddCommand(&cobra.Command{
		Use:   "stop",
		Short: "Stop running gateway",
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.Println("Stopping gateway...")
			// TODO: Implement in Phase G
			return nil
		},
	})
	cmd.AddCommand(&cobra.Command{
		Use:   "status",
		Short: "Show gateway health",
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.Println("Gateway status...")
			// TODO: Implement in Phase G
			return nil
		},
	})

	return cmd
}

func runGateway(cmd *cobra.Command, args []string) error {
	cmd.Printf("Starting gateway on %s, connecting to core at %s\n", gatewayTelnetAddr, gatewayCoreAddr)
	// TODO: Implement in Phase F
	return nil
}
```

**Step 5: Implement core.go**

```go
// cmd/holomush/core.go
package main

import (
	"github.com/spf13/cobra"
)

var (
	coreGRPCAddr    string
	coreDatabaseURL string
)

func NewCoreCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "core",
		Short: "Start the core process (engine, plugins)",
		RunE:  runCore,
	}

	cmd.Flags().StringVar(&coreGRPCAddr, "grpc-addr", "localhost:9000", "gRPC listen address")
	cmd.Flags().StringVar(&coreDatabaseURL, "database-url", "", "PostgreSQL connection string")
	cmd.MarkFlagRequired("database-url")

	// Subcommands
	cmd.AddCommand(&cobra.Command{
		Use:   "stop",
		Short: "Stop running core",
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.Println("Stopping core...")
			// TODO: Implement in Phase G
			return nil
		},
	})
	cmd.AddCommand(&cobra.Command{
		Use:   "status",
		Short: "Show core health",
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.Println("Core status...")
			// TODO: Implement in Phase G
			return nil
		},
	})

	return cmd
}

func runCore(cmd *cobra.Command, args []string) error {
	cmd.Printf("Starting core on %s\n", coreGRPCAddr)
	// TODO: Implement in Phase E
	return nil
}
```

**Step 6: Update main.go**

```go
// cmd/holomush/main.go
package main

import (
	"os"
)

var (
	version = "dev"
	commit  = "unknown"
	date    = "unknown"
)

func main() {
	cmd := NewRootCmd()
	cmd.Version = version + " (commit: " + commit + ", built: " + date + ")"

	if err := cmd.Execute(); err != nil {
		os.Exit(1)
	}
}
```

**Step 7: Run tests and commit**

```bash
task test
task lint
git add cmd/holomush/ go.mod go.sum
git commit -m "feat(cli): add Cobra CLI skeleton with gateway and core commands"
```

---

## Phase E: Core Process

_Detailed implementation follows same pattern - tests first, then implementation, then commit._

**Task E1: Core gRPC Service Implementation**

Files:

- Create: `internal/grpc/server.go`
- Create: `internal/grpc/server_test.go`
- Modify: `cmd/holomush/core.go` (wire up server)

---

## Phase F: Gateway Process

**Task F1: Gateway gRPC Client Implementation**

Files:

- Create: `internal/grpc/client.go`
- Create: `internal/grpc/client_test.go`
- Modify: `internal/telnet/handler.go` (use client instead of engine)
- Modify: `cmd/holomush/gateway.go` (wire up client)

---

## Phase G: Control Sockets

**Task G1: Control Socket Implementation**

Files:

- Create: `internal/control/socket.go`
- Create: `internal/control/socket_test.go`
- Modify: `cmd/holomush/core.go` (start control socket)
- Modify: `cmd/holomush/gateway.go` (start control socket)

---

## Phase H: Integration & Documentation

**Task H1: Integration Tests**

Files:

- Create: `tests/integration/process_test.go`
- Tests: Full Gateway+Core lifecycle, reconnection, mTLS

**Task H2: Documentation Updates**

Files:

- Update: `README.md`
- Update: `docs/reference/getting-started.md`
- Update: `docs/reference/architecture-overview.md`
- Create: `docs/reference/cli.md`
- Create: `docs/reference/deployment.md`
- Create: `docs/reference/observability.md`

---

## Task Summary

| Phase | Task               | Description                   | Dependencies           |
| ----- | ------------------ | ----------------------------- | ---------------------- |
| A1    | XDG utilities      | XDG Base Directory paths      | None                   |
| A2    | Structured logging | slog + OTEL trace context     | None                   |
| A3    | gRPC proto         | Service definitions + codegen | None                   |
| B1    | TLS certs          | mTLS certificate generation   | A1                     |
| C1    | DB migration       | game_id system_info table     | None                   |
| D1    | Cobra CLI          | Command skeleton with flags   | A1, A2                 |
| E1    | Core process       | gRPC server wrapping Engine   | A1, A2, A3, B1, C1, D1 |
| F1    | Gateway process    | gRPC client + telnet adapter  | E1                     |
| G1    | Control sockets    | HTTP on Unix socket           | E1, F1                 |
| H1    | Integration tests  | End-to-end testing            | G1                     |
| H2    | Documentation      | README, CLI, deployment docs  | H1                     |

---

## Execution Checklist

- [ ] A1: XDG utilities
- [ ] A2: Structured logging
- [ ] A3: gRPC proto definitions
- [ ] B1: TLS certificate generation
- [ ] C1: game_id database migration
- [ ] D1: Cobra CLI skeleton
- [ ] E1: Core gRPC service
- [ ] F1: Gateway gRPC client
- [ ] G1: Control socket
- [ ] H1: Integration tests
- [ ] H2: Documentation
